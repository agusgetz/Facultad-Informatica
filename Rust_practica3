
*Nota: Para todos los ejercicios realizar los tests de unidad correspondientes.

1- Escribir un programa que defina una estructura Persona que tenga campos para el
nombre, la edad y la dirección(que puede ser nulo al momento de la creación de una
persona). Para dicha estructura implemente los siguientes métodos:
➢ new: que pasando los parámetros correspondientes, crea una Persona y la retorna.
➢ to_string: que retorna un string con los datos de la persona concatenados sobre el
mensaje ejecutado por ej:
person.to_string() , donde person es una variable del tipo Persona.
➢ obtener_edad: retorna la edad de la persona.
➢ actualizar_direccion(nueva_direccion)*/

fn main() {
struct Persona {
nombre:String,
edad:u32,
direccion:Option <String> ,
}

impl Persona {

fn new (nombre:String, edad:u32, direccion:Option <String> ) -> Persona {
Persona {nombre,edad,direccion}
}

fn nueva_persona (&mut self,nombre:String, edad:u32, direccion:Option <String> ) {
self.nombre=nombre;
self.edad=edad;
self.direccion=direccion}
fn to_string (&self)-> String {
let a: String = self.edad.to_string();
let b: String = self.nombre.to_string();
let mut c: String = "sin direccion".to_string();
if self.direccion.is_some() { c= self.direccion.clone().unwrap()} ;
let mut output:String = a;
output.push_str(&b);
output.push_str(&c);
return output
}
fn obtener_edad (&self) -> u32{
let output:u32 = self.edad;
output
}
fn nueva_direccion (&mut self, direccion:Option<String> ) {
self.direccion = direccion;
}
}

let mut persona1 : Persona = Persona {nombre: "Fernanda".to_string(), edad: 45, direccion: Some ("calle 9".to_string()) };
println!(" {}",persona1.to_string());
println!(" {}",persona1.obtener_edad());
persona1.nueva_direccion(Some ("calle 14".to_string()));
println!(" {}",persona1.to_string());

let mut persona2 : Persona = Persona {nombre: " ".to_string(), edad: 00, direccion: None };
println!(" {}",persona2.to_string());
persona2.nueva_persona("Martin".to_string(), 28, Some ("calle 67".to_string()));
println!(" {}",persona2.obtener_edad());
persona2.nueva_direccion(Some ("calle 56".to_string()));
println!(" {}",persona2.to_string());


let mut persona3 : Persona = Persona {nombre: " ".to_string(), edad: 00, direccion: None };
println!(" {}",persona3.to_string());
persona3.nueva_persona("Pedro".to_string(), 65, Some ("calle 72".to_string()));
println!(" {}",persona3.obtener_edad());
persona3.nueva_direccion(None);
println!(" {}",persona3.to_string());

let mut persona4:Persona = Persona::new("Laura".to_string(), 50, None);
println!(" {}",persona4.to_string());

}

Escribir un programa que defina la estructura Rectángulo que tenga campos para la
longitud y el ancho. Para dicha estructura implemente los siguientes métodos:
➢ new: que pasando los parámetros correspondientes, crea un Rectángulo y lo
retorna.
➢ calcular_area: calcular el área y la retorna.
➢ calcular_perimetro: calcula el perímetro y lo retorna.
➢ es_cuadrado: retorna true si es cuadrado, false caso contrario */

struct rectangulos {
ancho: u32 ,
alto: u32
}
impl rectangulos {
fn new (ancho:u32, alto:u32) -> rectangulos{
rectangulos{ancho,alto}
}
fn calcular_perimetro (&self) -> u32 {
let resultado:u32;
resultado = self.ancho + self.alto;
resultado
}
fn calcular_area (&self) -> u32 {
let resultado:u32;
resultado = self.ancho * self.alto;
resultado
}
fn es_cuadrado (&self) -> bool {
let resultado:bool;
if self.ancho == self.alto {resultado=true} else {resultado= false};
resultado
}
}

fn main () {
let estruct :rectangulos = rectangulos::new(23,54);
println! ( "{}",estruct.calcular_area());
println! ( "{}",estruct.es_cuadrado());
println! ( "{}",estruct.calcular_perimetro());
}

* Escribir un programa que defina una estructura Fecha que tenga campos para el día, el
mes y el año. Para dicha estructura implemente los siguientes métodos:
➢ new: que pasando los parámetros correspondientes, crea una Fecha y la retorna.
➢ es_fecha_valida: retorna true si es una fecha válida, false caso contrario.//tenga en
cuenta los años bisiestos también.
➢ es_bisiesto: retorna true si el año de la fecha pertenece a un año bisiesto.
➢ sumar_dias(dias): suma la cantidad de días a la fecha, modificándose
➢ restar_dias(dias): resta la cantidad de días a la fecha, modificándose
➢ es_mayor(una_fecha): que retorna true si la fecha que recibe el mensaje es mayor a
la fecha pasada por parámetro. */

fn main () {

struct Fecha {
dia: u32 ,
mes: u32,
año: u32
}
impl Fecha {
fn new (dia:u32, mes:u32, año:u32) -> Fecha{
Fecha {dia, mes, año}
}
fn es_fecha_valida (&self) -> bool {
let output:bool;
if self.dia >=1 && self.dia <= 31 && self.mes >=1 && self.mes <= 12
&& self.año >=1984 && self.año <= 2026 {output = true}
else { output = false};
output
}
fn es_biciesto (&self) -> bool {
let output:bool;
if self.año == 2024 || self.año == 2020 || self.año == 2016 || self.año == 2012 || self.año == 2008 ||
self.año == 2004 || self.año == 2000 || self.año == 1996 || self.año == 1992 ||
self.año == 1988 || self.año == 1986 {output = true}
else
{output = false};
output
}
fn sumar_dias (&mut self, dias:u32) {
self.dia= self.dia + dias;
}
fn restar_dias (&mut self, dias:u32) {
self.dia= self.dia - dias;
}
fn es_mayor (&mut self, f:&Fecha) -> bool {
let output:bool;
if (f.año < self.año ) || (f.año == self.año && f.mes < self.mes) ||
(f.año == self.año && f.mes == self.mes && f.dia < self.dia) {output = true}
else
{ output = false};
output
}
}

let mut f:Fecha= Fecha::new(56, 23, 45);
let mut d:Fecha= Fecha::new(2, 6, 1990);
let mut g:Fecha=Fecha::new(5, 8, 1991);
println! ("{},{},{}",f.es_biciesto(),f.es_fecha_valida(),f.es_mayor(&g));
println! ("{},{},{}",d.es_biciesto(),d.es_fecha_valida(),d.es_mayor(&g));
}


ej 4

fn main () {
//moto
let marca: String = "Random".to_string();
let modelo: i32 = 2004;
let precio_bruto: f64 = 506_654.93;
let impuesto: Option<f64> = Some(309.0);
let moto1: Moto=Moto::new (marca,modelo,precio_bruto) ;
let cantidad= 7;
let precio_final: f64= moto1.calcular_precio_final(impuesto);
let mut venta1:Venta<Moto>=Venta::new(moto1, cantidad, precio_final, None);
let dato = venta1.precio_venta();
// auto
let marca: String = "Fiat".to_string();
let modelo: i32 = 2009;
let precio_bruto: f64 = 5_006_654.93;
let cantidad= 3;
let impuesto: Option<f64> = Some(1_492.0);
let bol=true;
let mut auto1: Auto=Auto::new (marca,modelo,precio_bruto,bol) ;
let precio_final: f64= auto1.calcular_precio_final(impuesto);
let mut venta2:Venta<Auto>=Venta::new(auto1, cantidad, precio_final, None);
let dato2 = venta2.precio_venta();
//
let mut mis_ventas =Vec::new();
mis_ventas.push(VentaVehiculo::VentaMoto(venta1));
mis_ventas.push(VentaVehiculo::VentaAuto(venta2));
for i in mis_ventas {println!("{:#?}",i)};
}
#[derive(Debug)]
struct Moto {
marca:String,
modelo:i32,
precio_bruto:f64,
}
impl Moto {
fn new (marca:String, modelo:i32, precio_bruto:f64) -> Moto {
Moto{marca,modelo,precio_bruto}
}
fn calcular_precio_final (&self, impuestos:Option<f64>) -> f64 {
let mut precio: f64 = self.precio_bruto;
if let Some (valor) = impuestos {precio+= valor};
precio
}
}
#[derive(Debug)]
struct Venta <T> {
producto:T,
cantidad:i32,
precio_final_unidad:f64,
precio_venta:Option<f64>
}
impl <T> Venta <T>{
fn new (producto:T, cantidad:i32, precio_final_unidad:f64, precio_venta:Option<f64>) ->Venta <T>{
Venta {producto,cantidad,precio_final_unidad,precio_venta}
}
fn precio_venta (&mut self) -> f64 {
let precio: f64 = self.precio_final_unidad * self.cantidad as f64;
self.precio_venta = Some(precio);
precio
}
}
#[derive(Debug)]
struct Auto {
marca:String,
modelo:i32,
precio_bruto:f64,
es_importado:bool
}
impl Auto {
fn new (marca:String, modelo:i32, precio_bruto:f64,es_importado:bool) -> Auto {
Auto {marca,modelo,precio_bruto,es_importado}
}
fn calcular_precio_final (&mut self, impuestos:Option<f64>) -> f64 {
let mut precio: f64 = self.precio_bruto;
if self.es_importado {precio= precio *1.3};
if let Some (valor) = impuestos {precio+= valor};
self.precio_bruto= precio;
precio
}
}
#[derive(Debug)]
enum VentaVehiculo {
VentaAuto(Venta <Auto>) ,
VentaMoto(Venta<Moto>)
}

